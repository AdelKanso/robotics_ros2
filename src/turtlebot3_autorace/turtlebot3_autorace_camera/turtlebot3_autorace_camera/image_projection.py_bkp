#!/usr/bin/env python3
import cv2
from cv_bridge import CvBridge
import numpy as np
from rcl_interfaces.msg import IntegerRange, ParameterDescriptor, SetParametersResult
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import CompressedImage, Image

class ImageProjection(Node):
    def __init__(self):
        super().__init__('image_projection')

        descriptor_top = ParameterDescriptor(
            description='projection range top.',
            integer_range=[IntegerRange(from_value=-200, to_value=400, step=1)]
        )
        descriptor_bottom = ParameterDescriptor(
            description='projection range bottom.',
            integer_range=[IntegerRange(from_value=0, to_value=800, step=1)]
        )
        descriptor_offset = ParameterDescriptor(
            description='horizontal projection offset.',
            integer_range=[IntegerRange(from_value=-400, to_value=400, step=1)]
        )

        # declare parameters including NEW independent top/bottom offsets
        self.declare_parameters(
            namespace='',
            parameters=[
                ('camera.extrinsic_camera_calibration.top_x', 60, descriptor_top),
                ('camera.extrinsic_camera_calibration.top_y', 50, descriptor_top),
                ('camera.extrinsic_camera_calibration.bottom_x', 260, descriptor_bottom),
                ('camera.extrinsic_camera_calibration.bottom_y', 140, descriptor_bottom),
                ('camera.extrinsic_camera_calibration.top_offset_x', 0, descriptor_offset),
                ('camera.extrinsic_camera_calibration.bottom_offset_x', 0, descriptor_offset),
                ('is_extrinsic_camera_calibration_mode', True)
            ]
        )

        # load parameters
        self.top_x = self.get_parameter('camera.extrinsic_camera_calibration.top_x').value
        self.top_y = self.get_parameter('camera.extrinsic_camera_calibration.top_y').value
        self.bottom_x = self.get_parameter('camera.extrinsic_camera_calibration.bottom_x').value
        self.bottom_y = self.get_parameter('camera.extrinsic_camera_calibration.bottom_y').value
        self.top_offset_x = self.get_parameter('camera.extrinsic_camera_calibration.top_offset_x').value
        self.bottom_offset_x = self.get_parameter('camera.extrinsic_camera_calibration.bottom_offset_x').value

        self.is_calibration_mode = self.get_parameter('is_extrinsic_camera_calibration_mode').value
        if self.is_calibration_mode:
            self.add_on_set_parameters_callback(self.cbGetImageProjectionParam)

        self.sub_image_type = 'compressed'
        self.pub_image_type = 'raw'

        # Subscribers
        if self.sub_image_type == 'compressed':
            self.sub_image_original = self.create_subscription(
                CompressedImage,
                '/camera/image_input/compressed',
                self.cbImageProjection,
                1
            )
        else:
            self.sub_image_original = self.create_subscription(
                Image,
                '/camera/image_input',
                self.cbImageProjection,
                1
            )

        # Publishers
        if self.pub_image_type == 'raw':
            self.pub_image_projected = self.create_publisher(Image, '/camera/image_output', 1)
        else:
            self.pub_image_projected = self.create_publisher(
                CompressedImage, '/camera/image_output/compressed', 1
            )

        if self.is_calibration_mode:
            if self.pub_image_type == 'raw':
                self.pub_image_calib = self.create_publisher(Image, '/camera/image_calib', 1)
            else:
                self.pub_image_calib = self.create_publisher(
                    CompressedImage, '/camera/image_calib/compressed', 1
                )

        self.cvBridge = CvBridge()

    def cbGetImageProjectionParam(self, params):
        for param in params:
            if param.name.endswith('top_x'):
                self.top_x = int(param.value)
            if param.name.endswith('top_y'):
                self.top_y = int(param.value)
            if param.name.endswith('bottom_x'):
                self.bottom_x = int(param.value)
            if param.name.endswith('bottom_y'):
                self.bottom_y = int(param.value)
            if param.name.endswith('top_offset_x'):
                self.top_offset_x = int(param.value)
            if param.name.endswith('bottom_offset_x'):
                self.bottom_offset_x = int(param.value)
        return SetParametersResult(successful=True)

    def cbImageProjection(self, msg_img):
        # Decode image
        if self.sub_image_type == 'compressed':
            arr = np.frombuffer(msg_img.data, np.uint8)
            cv_image_original = cv2.imdecode(arr, cv2.IMREAD_COLOR)
        else:
            cv_image_original = self.cvBridge.imgmsg_to_cv2(msg_img, 'bgr8')

        # Get image resolution dynamically
        h_img, w_img, _ = cv_image_original.shape
        cx = w_img // 2
        cy = h_img // 2

        top_x, top_y = self.top_x, self.top_y
        bottom_x, bottom_y = self.bottom_x, self.bottom_y
        tox = self.top_offset_x
        box = self.bottom_offset_x

        # Calibration visualization (red trapezoid)
        if self.is_calibration_mode:
            img_calib = cv_image_original.copy()
            cv2.line(img_calib, (cx - top_x + tox, cy - top_y), (cx + top_x + tox, cy - top_y), (0, 0, 255), 2)
            cv2.line(img_calib, (cx - bottom_x + box, cy + bottom_y), (cx + bottom_x + box, cy + bottom_y), (0, 0, 255), 2)
            cv2.line(img_calib, (cx - bottom_x + box, cy + bottom_y), (cx - top_x + tox, cy - top_y), (0, 0, 255), 2)
            cv2.line(img_calib, (cx + bottom_x + box, cy + bottom_y), (cx + top_x + tox, cy - top_y), (0, 0, 255), 2)

            if self.pub_image_type == 'raw':
                self.pub_image_calib.publish(self.cvBridge.cv2_to_imgmsg(img_calib, 'bgr8'))
            else:
                self.pub_image_calib.publish(self.cvBridge.cv2_to_compressed_imgmsg(img_calib, 'jpg'))

        # ------------------ Homography Transform ------------------
        pts_src = np.array([
            [cx - top_x + tox,    cy - top_y],
            [cx + top_x + tox,    cy - top_y],
            [cx + bottom_x + box, cy + bottom_y],
            [cx - bottom_x + box, cy + bottom_y]
        ], dtype=np.float32)

        dst_top_left = [50, 50]
        dst_top_right = [750, 50]
        dst_bottom_right = [750, 550]
        dst_bottom_left = [50, 550]

        pts_dst = np.array([dst_top_left, dst_top_right, dst_bottom_right, dst_bottom_left], dtype=np.float32)

        h_matrix, status = cv2.findHomography(pts_src, pts_dst)
        if h_matrix is None:
            self.get_logger().warn('findHomography returned None â€” publishing original image')
            warped = cv_image_original.copy()
        else:
            warped = cv2.warpPerspective(cv_image_original, h_matrix, (800, 600))

        if self.pub_image_type == 'raw':
            self.pub_image_projected.publish(self.cvBridge.cv2_to_imgmsg(warped, 'bgr8'))
        else:
            self.pub_image_projected.publish(self.cvBridge.cv2_to_compressed_imgmsg(warped, 'jpg'))


def main(args=None):
    rclpy.init(args=args)
    node = ImageProjection()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
