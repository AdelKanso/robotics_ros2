#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import CompressedImage, LaserScan
from cv_bridge import CvBridge
import cv2
import numpy as np
import math

class LineToScan(Node):
    def __init__(self):
        super().__init__('line_to_scan')
        self.bridge = CvBridge()
        # Configurable parameters
        self.declare_parameter('camera_frame', 'camera_link')
        self.declare_parameter('scan_frame', 'camera_link')  # publish virtual scan in camera frame
        self.declare_parameter('fov_horizontal_deg', 62.0)
        self.declare_parameter('img_w', 640)
        self.declare_parameter('img_h', 480)
        self.declare_parameter('resolution_m_per_pixel', 0.005)  # tune: 0.003-0.01
        self.declare_parameter('max_range', 2.0)
        self.declare_parameter('fake_obstacle_dist', 0.20)  # distance to publish for virtual obstacles (m)

        self.camera_frame = self.get_parameter('camera_frame').get_parameter_value().string_value
        self.scan_frame = self.get_parameter('scan_frame').get_parameter_value().string_value
        self.fov_horizontal = math.radians(self.get_parameter('fov_horizontal_deg').get_parameter_value().double_value)
        self.img_w = int(self.get_parameter('img_w').get_parameter_value().integer_value)
        self.img_h = int(self.get_parameter('img_h').get_parameter_value().integer_value)
        self.resolution = self.get_parameter('resolution_m_per_pixel').get_parameter_value().double_value
        self.max_range = self.get_parameter('max_range').get_parameter_value().double_value
        self.fake_obstacle_dist = self.get_parameter('fake_obstacle_dist').get_parameter_value().double_value

        self.scan_pub = self.create_publisher(LaserScan, '/virtual_line_scan', 10)
        self.sub = self.create_subscription(CompressedImage, '/detect/image_lane/compressed', self.callback, 10)

        self.angle_min = -self.fov_horizontal / 2.0
        self.angle_max = self.fov_horizontal / 2.0
        self.angle_increment = self.fov_horizontal / float(self.img_w)
        self.range_min = 0.01
        self.range_max = self.max_range

        self.get_logger().info(f'LineToScan running: frame={self.scan_frame}, fov_deg={math.degrees(self.fov_horizontal):.1f}')

    def callback(self, msg: CompressedImage):
        try:
            # decode image
            cv_image = self.bridge.compressed_imgmsg_to_cv2(msg, 'bgr8')
            # ensure size matches parameters (resize if needed)
            if (cv_image.shape[1], cv_image.shape[0]) != (self.img_w, self.img_h):
                cv_image = cv2.resize(cv_image, (self.img_w, self.img_h))

            # use HSV for robust color detection
            hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)

            # tuned ranges â€” you will likely need to tweak these
            yellow_lower = np.array([15, 100, 100])
            yellow_upper = np.array([35, 255, 255])
            white_lower = np.array([0, 0, 200])
            white_upper = np.array([180, 40, 255])

            yellow_mask = cv2.inRange(hsv, yellow_lower, yellow_upper)
            white_mask = cv2.inRange(hsv, white_lower, white_upper)
            line_mask = cv2.bitwise_or(yellow_mask, white_mask)

            # Clean up mask a bit
            kernel = np.ones((3,3), np.uint8)
            line_mask = cv2.morphologyEx(line_mask, cv2.MORPH_OPEN, kernel)
            line_mask = cv2.morphologyEx(line_mask, cv2.MORPH_DILATE, kernel)

            contours, _ = cv2.findContours(line_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

            num_rays = int((self.angle_max - self.angle_min) / self.angle_increment) + 1
            # initial: no obstacle => use max_range (Cartographer interprets far as free)
            ranges = [self.range_max] * num_rays

            valid_points = 0
            # For each contour point, compute angle/distance relative to the camera forward axis
            for contour in contours:
                if contour.shape[0] < 6:
                    continue
                # iterate through points (squeeze for convenience)
                pts = contour.squeeze()
                if pts.ndim == 1:
                    pts = np.expand_dims(pts, 0)
                for (cx, cy) in pts:
                    # coordinate: cx from left, cy from top
                    x_rel = (cx - (self.img_w / 2.0)) * self.resolution   # positive => right
                    y_rel = (self.img_h - cy) * self.resolution            # pixel bottom => forward
                    if y_rel <= 0.001:
                        continue
                    dist = math.hypot(x_rel, y_rel)
                    if dist > self.max_range or dist <= self.range_min:
                        continue
                    # angle measured from forward (x-axis forward), positive counter-clockwise (left)
                    angle = math.atan2(x_rel, y_rel)  # lateral, forward -> angle positive to right, but we'll keep convention
                    # NOTE: we treat positive to the right; we will keep this consistent when transforming
                    if angle < self.angle_min or angle > self.angle_max:
                        continue
                    idx = int((angle - self.angle_min) / self.angle_increment)
                    if 0 <= idx < len(ranges):
                        # Make lane lines strong obstacles: publish a near/fixed distance so SLAM treats them as walls.
                        # We use a small "fake" distance but greater than range_min.
                        ranges[idx] = min(ranges[idx], self.fake_obstacle_dist)
                        valid_points += 1

            # Publish LaserScan in camera frame
            scan = LaserScan()
            scan.header.stamp = self.get_clock().now().to_msg()
            scan.header.frame_id = self.scan_frame
            scan.angle_min = self.angle_min
            scan.angle_max = self.angle_max
            scan.angle_increment = self.angle_increment
            scan.time_increment = 0.0
            scan.scan_time = 0.1
            scan.range_min = self.range_min
            scan.range_max = self.range_max
            scan.ranges = ranges

            self.scan_pub.publish(scan)
            self.get_logger().debug(f'Published virtual scan with {valid_points} line points')
        except Exception as e:
            self.get_logger().warn(f'LineToScan error: {e}', throttle_duration_sec=5.0)


def main(args=None):
    rclpy.init(args=args)
    node = LineToScan()
    try:
        rclpy.spin(node)
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
